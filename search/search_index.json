{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MayPy","text":"<p>Pythonic Java Optional API</p> <p> </p> <p>Source Code: https://github.com/MLetrone/maypy</p> <p>documentation: https://mletrone.github.io/maypy/</p> <p>Maypy is python implementation of the well known Java Optional API. It's designed to help you handle potential <code>None</code> values, reducing error from <code>NoneType</code>.</p>"},{"location":"#features","title":"Features :","text":"<ul> <li>Brings functional programming</li> <li>Easy to use</li> <li>Fully typed and compatible with <code>mypy</code> !</li> <li>Lightweight</li> </ul>"},{"location":"#description","title":"Description","text":"<p>It's not rare to handle return from function that maybe either a value or None. Like <code>.get</code> from a dictionary, results from api or ORM etc. With no more <code>if value is None</code> with <code>MayPy</code>, encapsulate your value and do what you want to.</p> <p>MayPy brings <code>Maybe</code> a wrapper (container), it is either empty if the value passed was <code>None</code> or valuated, in this case it contains the value, and we can perform operation on it.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#maypy","title":"Maypy","text":""},{"location":"changelog/#100-2024-09-13","title":"1.0.0 (2024-09-13)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>add maybe container</li> <li>add functional interfaces</li> </ul>"},{"location":"exceptions/","title":"Exceptions","text":""},{"location":"exceptions/#maypy._exceptions-classes","title":"Classes","text":""},{"location":"exceptions/#maypy._exceptions.EmptyMaybeException","title":"EmptyMaybeException","text":"<p>               Bases: <code>MaybeException</code></p> <p>Exception warning that the maybe contains no value to get.</p>"},{"location":"exceptions/#maypy._exceptions.MaybeException","title":"MaybeException","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for Maybe.</p>"},{"location":"functional/","title":"Functionals","text":""},{"location":"functional/#maypy._functional-classes","title":"Classes","text":""},{"location":"functional/#maypy._functional.Mapper","title":"Mapper","text":"<p>               Bases: <code>Protocol[T_MAPPER, V]</code></p> <p>Protocol describing mapper function.</p> <p>The corresponding signature is <code>Callable[[T], V]</code>.</p> <p>Its goal is to transform a value to another. (can be a named function or lambda function).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lambda val: val * 15\n&gt;&gt;&gt; # OR\n&gt;&gt;&gt; from numbers import Number\n&gt;&gt;&gt; def multiply_by_ten(val: int) -&gt; int:\n&gt;&gt;&gt;     return 10 * val\n</code></pre>"},{"location":"functional/#maypy._functional.Mapper-functions","title":"Functions","text":""},{"location":"functional/#maypy._functional.Mapper.__call__","title":"__call__","text":"<pre><code>__call__(val: T) -&gt; V\n</code></pre> <p>Mapping logic.</p>"},{"location":"functional/#maypy._functional.Predicate","title":"Predicate","text":"<p>               Bases: <code>Protocol[T]</code></p> <p>Protocol describing predicate function.</p> <p>The corresponding signature is <code>Callable[[T], bool]</code>.</p> <p>Its goal is to verify if a value <code>T</code> match the conditions define. (can be a named function or lambda function).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lambda string: bool(string) and bool(string.strip())\n&gt;&gt;&gt; # OR\n&gt;&gt;&gt; from typing import Sequence\n&gt;&gt;&gt;\n&gt;&gt;&gt; def is_empty(seq: Sequence) -&gt; bool:\n&gt;&gt;&gt;     return len(seq) == 0\n</code></pre>"},{"location":"functional/#maypy._functional.Predicate-functions","title":"Functions","text":""},{"location":"functional/#maypy._functional.Predicate.__call__","title":"__call__","text":"<pre><code>__call__(val: T) -&gt; bool\n</code></pre> <p>Predicate logic.</p>"},{"location":"functional/#maypy._functional.Supplier","title":"Supplier","text":"<p>               Bases: <code>Protocol[V]</code></p> <p>Protocol describing supplier function.</p> <p>The corresponding signature is <code>Callable[[], None]</code>.</p> <p>Its goal is to supply a new <code>V</code> value at invocation. (can be a named function or lambda function).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lambda: list(range(5))\n&gt;&gt;&gt; # OR\n&gt;&gt;&gt; def create_list() -&gt; list[int]:\n&gt;&gt;&gt;     return list(range(5))\n</code></pre>"},{"location":"functional/#maypy._functional.Supplier-functions","title":"Functions","text":""},{"location":"functional/#maypy._functional.Supplier.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; V\n</code></pre> <p>Supply logic.</p>"},{"location":"installation/","title":"Installation","text":"<p>Information</p> <p>MayPy is pur Python code with no external dependencies at its core. So don't worry to use it  !</p>"},{"location":"installation/#install-with-pip","title":"Install with pip","text":"pip install maypyinstalled! <p>Tip</p> <p>Don't forget to use a virtual environment when installing library, otherwise it will be installed on your global python environment.</p>"},{"location":"installation/#install-with-poetry","title":"Install with poetry","text":"<p>Information</p> <p>Poetry is a great tools to manage your dependencies and packaging. I highly recommend to check it if you don't know Learn more </p> poetry add maypyInstalling maypywriting lock file"},{"location":"maybe/","title":"Maybe","text":""},{"location":"maybe/#maypy._maybe-classes","title":"Classes","text":""},{"location":"maybe/#maypy._maybe.Maybe","title":"Maybe","text":"<p>               Bases: <code>ABC</code>, <code>Generic[VALUE]</code></p> <p>Wrapper class inspired by the well-known Optional API from Java.</p> <p>A Maybe is container, a non-none value may be inside or may be not (hence the name Maybe as an alternative to Optional, which is already used by Python).</p> <p>If a value is present: <code>is_present</code> will return True and <code>get</code> will return the value.</p> <p>It useful when working with data that can be none.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; beer = json.loads(json_beer)\n&gt;&gt;&gt; # Without maybe\n&gt;&gt;&gt; price = beer.get(\"BeerPrice\")\n&gt;&gt;&gt; if price:\n&gt;&gt;&gt;     if price &gt; 0:\n&gt;&gt;&gt;         price = convertDollarsToEuro(price)\n&gt;&gt;&gt; else:\n&gt;&gt;&gt;     raise MyCustomException()\n&gt;&gt;&gt; #  with Maybe\n&gt;&gt;&gt; Maybe.of(beer.get(\"BeerPrice\")).\n&gt;&gt;&gt;     filter(lambda price: price &gt; 0).\n&gt;&gt;&gt;     map(convertDollarsToEuro).\n&gt;&gt;&gt;     or_else_raise(MyCustomException())\n&gt;&gt;&gt;\n</code></pre>"},{"location":"maybe/#maypy._maybe.Maybe-functions","title":"Functions","text":""},{"location":"maybe/#maypy._maybe.Maybe.empty","title":"empty  <code>staticmethod</code>","text":"<pre><code>empty() -&gt; Maybe[Any]\n</code></pre> <p>Returns a empty <code>Maybe</code> instance.</p>"},{"location":"maybe/#maypy._maybe.Maybe.filter","title":"filter  <code>abstractmethod</code>","text":"<pre><code>filter(predicate: Predicate[VALUE]) -&gt; Maybe[VALUE]\n</code></pre> <p>Filter the wrapped value (if present).</p> <p>If it matches the predicate, returns a Maybe describing the value, otherwise return an empty Maybe.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[VALUE]</code> <p>predicate function to apply to the value.</p> required <p>Returns:</p> Type Description <code>Maybe[VALUE]</code> <p>A Maybe containing the value if it matched the predicate, else an empty Maybe.</p>"},{"location":"maybe/#maypy._maybe.Maybe.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get() -&gt; VALUE\n</code></pre> <p>Return the value if present, else raise EmptyElementException.</p> <p>Returns:</p> Type Description <code>VALUE</code> <p>The non-None value contained in this Maybe.</p> <p>Raises:</p> Type Description <code>EmptyElementException</code> <p>if no value present.</p>"},{"location":"maybe/#maypy._maybe.Maybe.if_present","title":"if_present  <code>abstractmethod</code>","text":"<pre><code>if_present(consumer: Callable[[VALUE], None]) -&gt; None\n</code></pre> <p>Invoke the given consumer with the value if present, do nothing otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>consumer</code> <code>Callable[[VALUE], None]</code> <p>function to be executed if value present.</p> required"},{"location":"maybe/#maypy._maybe.Maybe.is_empty","title":"is_empty  <code>abstractmethod</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Returns True if value is not present, otherwise False.</p>"},{"location":"maybe/#maypy._maybe.Maybe.is_present","title":"is_present  <code>abstractmethod</code>","text":"<pre><code>is_present() -&gt; bool\n</code></pre> <p>Returns True if value is present, otherwise False.</p>"},{"location":"maybe/#maypy._maybe.Maybe.map","title":"map  <code>abstractmethod</code>","text":"<pre><code>map(mapper: Mapper[VALUE, OUTPUT]) -&gt; Maybe[OUTPUT]\n</code></pre> <p>Map the wrapped value (if present).</p> <p>Apply the given mapping function to the value.</p> <p>Parameters:</p> Name Type Description Default <code>mapper</code> <code>Mapper[VALUE, OUTPUT]</code> <p>mapping function to apply to the value.</p> required <p>Returns:</p> Type Description <code>Maybe[OUTPUT]</code> <p>A Maybe containing the result of applying the mapping function on the value,</p> <code>Maybe[OUTPUT]</code> <p>if value is present else an empty Maybe.</p>"},{"location":"maybe/#maypy._maybe.Maybe.of","title":"of  <code>staticmethod</code>","text":"<pre><code>of(val: Optional[VALUE]) -&gt; Maybe[VALUE]\n</code></pre> <p>Returns a <code>Maybe</code> instance depends on the value provided.</p> <p>If it's a none value, an empty <code>Maybe</code> will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>Optional[VALUE]</code> <p>the provided value to wrap.</p> required <p>Returns:</p> Type Description <code>Maybe[VALUE]</code> <p>A Maybe containing the value, if non-None value, otherwise an empty Maybe.</p>"},{"location":"maybe/#maypy._maybe.Maybe.or_else","title":"or_else  <code>abstractmethod</code>","text":"<pre><code>or_else(other: Union[VALUE, Supplier[VALUE]]) -&gt; VALUE\n</code></pre> <p>Returns the value if present, else return other.</p> <p>If other is a supplier, it returns the result of the invocation.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[VALUE, Supplier[VALUE]]</code> <p>value to be return if no value present. if other is a supplier function, returns the invocation instead.</p> required <p>Returns:</p> Type Description <code>VALUE</code> <p>The value held by this Maybe if non-None value, otherwise either other or other invocation.</p>"},{"location":"maybe/#maypy._maybe.Maybe.or_else_raise","title":"or_else_raise  <code>abstractmethod</code>","text":"<pre><code>or_else_raise(exception: Exception) -&gt; VALUE\n</code></pre> <p>Returns the value if present, otherwise raise the given exception.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>The exception to be raised if no value present.</p> required"},{"location":"maybe/#maypy._maybe.Maybe.or_none","title":"or_none  <code>abstractmethod</code>","text":"<pre><code>or_none() -&gt; Optional[VALUE]\n</code></pre> <p>Returns the value if present, else return None.</p> <p>Returns:</p> Type Description <code>Optional[VALUE]</code> <p>The value held by this <code>Maybe</code> if non-None value, otherwise None.</p>"},{"location":"usage/","title":"Usage","text":"<p>The purpose of MayPy is to provide a type-level solution for representing and manipulating optional values instead of None reference. This away around, no need to worry about the optional value and testing it, before applying process on it.</p> <p>There are two types of Maybe container, either it contains a value or it is empty.</p> <p>A Maybe object become empty when the value it should contain is <code>None</code>.</p>"},{"location":"usage/#create-maybe-objects","title":"Create Maybe objects","text":""},{"location":"usage/#empty","title":"Empty","text":"<p>There are 3 ways to have a empty Maybe.</p> <pre><code>from maypy import Empty, Maybe\n\nassert Maybe.of(None) == Maybe.empty() == Empty\n</code></pre> <p>Note</p> <p><code>Maybe.of(None)</code> is here as an example, for readability use the others to instantiate an empty Maybe.</p>"},{"location":"usage/#valuated","title":"Valuated","text":"<p>Valuated Maybe is quite straightforward, provide some value whatever it is, as long as is not <code>None</code> to <code>of</code> .</p> <pre><code>assert Maybe.of(12)\n</code></pre>"},{"location":"usage/#checking-value-presence","title":"Checking value presence","text":"<p>There are three methods to check if the value is present or not.</p> <p>Either by using <code>is_present</code> to know if the container has a value  or use <code>is_empty</code> to verify the absence of value. Another approach is to examine the \"truthiness\" of Maybe.</p> is_presentis_emptytruthiness <pre><code>name = Maybe.of(\"name\")\nassert name.is_present()\n\nname = Maybe.empty()\nassert not name.is_present()\n</code></pre> <pre><code>name = Maybe.of(\"name\")\nassert not name.is_empty()\n\nname = Maybe.empty()\nassert name.is_empty()\n</code></pre> <pre><code>assert Maybe.of(\"name\")\n\nassert not Maybe.empty()\n</code></pre>"},{"location":"usage/#get-wrapped-value","title":"Get wrapped value","text":"<p>To retrieve the value contained inside a Maybe, the method <code>get</code> returns it or raises an <code>EmptyMaybeException</code>.</p> <pre><code>assert Maybe.of(\"Mathieu\").get() == \"Mathieu\"\nassert Maybe.empty().get()\n&gt;&gt;&gt; EmptyMaybeException\n</code></pre>"},{"location":"usage/#handle-emptiness","title":"Handle Emptiness","text":""},{"location":"usage/#default-value","title":"Default value","text":"<p>When Maybe is empty, it's possible to provide a default value using <code>or_else</code>. Taking either a value or a <code>Supplier</code>  (with mypy the value provide as default should be the same type as the hypothetical value wrapped).</p> by valueby Supplier <pre><code>assert Maybe.empty().or_else(12) == 12\n\nassert Maybe.of(\"present\").or_else(\"absent\") == \"present\"\n</code></pre> <p>Warning</p> <p>It is indeed possible to do this way in pur python.</p> <pre><code>assert (\"present\" or \"absent) == \"present\"\n\nassert (None or 12) == 12\n</code></pre> <p>However, it is using the \"truthiness\" of the first element, it does not mean that the element is None!</p> <pre><code>&gt;&gt;&gt; assert (0 or 12) == 0\n&gt;&gt;&gt; AssertionError\n</code></pre> <pre><code>assert Maybe.empty().or_else(lambda: 12) == 12\n\nassert Maybe.of(\"present\").or_else(lambda: \"absent\") == \"present\"\n</code></pre> <p>Tips</p> <p>We may wonder what is the different between passing the function and calling it as the default value. The function is used only if Maybe is empty, whereas in the other hands, it will be invoked no matter what.</p> <pre><code>def populate_data() -&gt; list[str]:\n    print(\"invocation of populate_data\")\n    return [\"python\", \"c++\", \"c\", \"java\"]\n\nassert Maybe.empty().or_else(populate_data) == [\"python\", \"c++\", \"c\", \"java\"]\n&gt;&gt;&gt; \"invocation of populate_data\"\nassert Maybe.of([\"ruby\", \"kotlin\"]).or_else(populate_data) == [\"ruby\", \"kotlin\"]\nassert Maybe.of([\"ruby\", \"kotlin\"]).or_else(populate_data()) == [\"ruby\", \"kotlin\"]\n&gt;&gt;&gt; \"invocation of populate_data\"\n</code></pre>"},{"location":"usage/#raise-error","title":"Raise error","text":"<p>Another approach for handling value absence, is to raise a custom exception by  <code>or_else_raise</code> when Maybe is empty.</p> <pre><code>class CustomError(Exception):\n    pass\n\nassert Maybe.empty().or_else_raise(CustomError())\n&gt;&gt;&gt; CustomError\nassert Maybe.of(12).or_else_raise(CustomError()) == 12\n</code></pre>"},{"location":"usage/#manipulating-the-value","title":"Manipulating the value","text":"<p>Note</p> <p>In the further examples, I keep using lambda function to keep it simple and easy to read. It totally possible to use named function, no matter what you use as long as it respects the API contract.</p> <p>By the way <code>mypy</code> will infer types even with lambda !!!</p>"},{"location":"usage/#filtering","title":"Filtering","text":"<p>It is possible to perform inline condition on our wrapped value with <code>filter</code>. Taking a <code>Predicate</code>, it will check if the value matches the predicate and returning Maybe itself when passing, otherwise an empty Maybe is returned.</p> <pre><code>price = 999.99\n\nassert Maybe.of(price).filter(lambda x: x &lt;= 1000).is_present()\nassert Maybe.of(price).filter(lambda x: x &gt;= 1000).is_empty()\n</code></pre> <p>You may wonder why using it and what is the gain. Let's dive on a more concrete example!</p> <p>You want to watch a movie, and you ony care about its release date. It should be in certain interval.</p> <pre><code>from dataclasses import dataclass, field\n\n@dataclass\nclass Movie:\n    director: str\n    title: str\n    year: int\n    genre: list[str] = field(default_factory=list)\n    oscars: list[str] | None = field(default=None)\n</code></pre> <p>without Maybe:</p> <pre><code>from maypy import Predicate\n\n\ndef interval_checker(start_year: int, end_year: int) -&gt; Predicate[Movie]:\n    def is_in_range(movie: Movie | None) -&gt; bool:\n        if movie is not None:\n            return start_year &lt;= movie.year &lt;= end_year\n        return False\n\n    return is_in_range\n\n\nmovie = Movie(\"Luc Besson\", \"Taxi\", 1998, [\"comedy\"])\n\nassert interval_checker(1990, 2005)(movie)\nassert not interval_checker(2000, 2020)(movie)\nassert not interval_checker(2000, 2020)(None)\n</code></pre> <p>with Maybe: <pre><code>assert Maybe.of(movie).filter(lambda film: 1990 &lt;= film.year &lt;= 2005).is_present()\n</code></pre></p>"},{"location":"usage/#mapping","title":"Mapping","text":"<p>With a similar syntax, we can transform the value inside Maybe using  <code>map</code>.</p> <p>Reusing a last example, getting the number of oscars rewarding the movie.</p> <pre><code>movie = Movie(\"Luc Besson\", \"Taxi\", 1998, [\"comedy\"])\n\nassert (\n        Maybe.of(movie)\n        .map(lambda film: movie.oscars)\n        .map(lambda oscars: len(oscars))\n        .or_else(0) == 0\n)\n</code></pre> <p>It is powerful to chain filter and map together. Like checking the correctness of an input by a user.</p> <pre><code>VALID_BOOLS = (\"y\", \"n\", \"yes\", \"no\")\n\nuser_input = \"y \"\n\nassert (\n    Maybe.of(user_input)\n    .map(lambda input_: input_.strip())\n    .filter(lambda x: x in VALID_BOOLS)\n    .is_present()\n)\n</code></pre>"},{"location":"usage/#conditional-action","title":"Conditional action","text":"<p>The last method is <code>if_present</code>, it allows to perform some code, using a <code>Consumer</code> function (<code>Callable[[VALUE], None]</code>), on the wrapped value if present, otherwise nothing will happen.</p> <pre><code>Maybe.of(\"name\").if_present(lambda val: print(val))\n</code></pre> <p>Warning</p> <p>To keep it functional, the function passed should not modify the value but only use it. Please use chaining of <code>map</code> and get the value instead.</p>"}]}